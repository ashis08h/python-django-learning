class is a blueprint of an object which will have all the properties and methods.
where properties are the data and methods are the action to be performed.

object is an instance of a class which will have their own properties and methods.
what are the methods which is defined inside a class their objects can use those methods.

For example Person is a class it has their properties like name, age, dob and some methods like
CanTalk(), CanWalk(), CanBreathe()

Abstract class

Abstract class are a special type of class which can not be instantiated, In python we can create
abstract class with help of ABC class from abc module. Basically it is a blueprint of the their child
class.

Abstract methods are a part of abstract class which will not have their implementation in abstract
class their implementation will be present into their child class.
we can create abstract method with help of abstractmethod decorator.

Access modifiers or access specifiers in python are used to limit the access of a class variable
or class methods outside of a class.

There are three types of access modifiers in python

1) Public -
By default all the variables or methods which we create are public in nature. we can access these
variables or methods outside of a class. All the instance variables which is used after self keyword
are public variable.

2) Private -
When we declare a variable with double underscore are private in nature we can not use these variables
or methods outside of a class.

3) Protected -
when we declare a variable with single underscore are protected in nature. we can access these
variables outside of a class. generally we use protected variable for coding convention purpose.

Class method are a special type of method in python. We use class method to change the value of a
class variable which is declared globally in to that class. Generally we declare class methods with
@classmethod decorator.

constructor a special type of methods present in a class which is automatically getting invoked
once we create an object of that class. In python we use dunder method to create constructor __init__.
when we pass argument from an object then we use constructor to defined those variables inside that
class.

There are two types of constructor in python
1) Parameterized constructor -
When we pass argument from an object creation then it is parameterized constructor.
2) Default constructor -
when we do not have any argument while creating object then it is default constructor.

Class method used as alternative constructor -

We can use class method as an alternative constructor in python.
For example we are creating objects from two places and from both the places if we get argument
in different formats then we use the class methods as an alternative constructor.

Decorator in python are a special function that modifies or extents the behaviour of another methods
without changing the code. Decorator allow for adding functionality to an existing function in clean, readable and
reusable way.

Decorator in a python are a special type of function which takes a function as an argument and
change the original method and return the another method. We declare decorator with @ symbol.

dir method dir() will return all the methods, attribute of that thing which is passed under
parenthesis.

__dict__ it is a dunder method which is used to return into dictionary

help() it is also a method which is used to give information of things which is passed under
the ()

dunder method - This is a special type of method which are used inside a class to manipulate the
behaviour of an object. This is also known as magical method.

__init__, __str__, __len__, __dict__

Encapsulation in oops are a way to hide the internal state of an object and the methods of that class
can only be accessed through their object only.

The benefit of encapsulation is we can protect our class to get access from unwanted places.
Generally we do encapsulation with help of access modifiers.

functional_caching - it is a technique in python which is used to store the result of a function
and we can re use that result as per the requirement.
we use @lru_cache decorator to do function caching.

generators are a special type of method in the python which is used to create iterable sequence.
it create a sequence on the fly whenever we request for next value then only it creates
the sequence. the benefit of generator are it takes less memory. We use yield keyword to generate
sequence.

getter is a method in python from which we can access the value of a property of a class.
we use @property decorator to behave our methods as a property.

setter is a method in python from which we can set the value of a property of a class.
we use @method_name.setter decorator to set a value of a property.

Inheritance -
In Inheritance we derive a class from a base class there after all the properties and methods of
base class will be derived by the child class. In addition to that the derived class may have
their own methods and properties.

There are 5 types of inheritance in python

Single inheritance
When we derive a class from a single parent class it is known as single inheritance
this is basic inheritance.

Multiple Inheritance
When we derived a class with multiple parent class it is called multiple inheritance

Multilevel Inheritance
When we derive a class from a parent class and one more class is derived from that child
class it is known as multilevel inheritance

Hierarichal inheritance
when we derive multiple child class from a single parent class it is known as hierarichal inheritance

hybrid inheritance
when we use more that one type of inheritance together it is known as hybrid inheritance.

class variable are a variable which is declared inside a class but outside of any methods present
in that class.
Generally we store those type of values in the class variables which are common to all the instance.

Instance variable are present inside a method of a class. it defined under __init__ method or we
can say constructor of a class generally we store those type of values inside an instance variable
which are their for each instance.

Polymorphism is a feature in python where we will have similar objects of different classes.
we treat that object as an object of common class.

There are two types of polymorphism in oops.

Compile time polymorphism
In compile time polymorphism we will have same name of methods multiple times with different
number of arguments. In python we handle this scenario with help of optional parameter.
This is also known as method overloading.

Runtime polymorphism
In run time polymorphism we define a method of parent class from child class.
This is also known as method overriding.

Oops -
Before we were using procedural programing language where we used to write logic inside methods.
then we have shifted to oops where we write our logics in methods but we keep related methods
and properties together inside a class. and we access the methods and the properties with help of
objects. Oops also maps our variables with real world concepts.

There are some features of oops

Inheritance
Polymorphism
Encapsulation

Operator overloading -
Operator overloading is a feature in python where we redefined the behaviour of mathematical operator
and comparison operator.
In python we have few of them

__add__, __sub__, __mul__

We use modules and package to modularize our code
modularized means - reusable, modular, and organized.
Module - module in python is a .py file which will have method, variables and classes.
we can use these methods, variables and classes after importing into the main scripts.
the benefit of creating module is to avoid clashes between global variables.

import module1

package are a collection of modules which is used in bigger projects.
__init__.py will be there inside package.
similar to modules package also used to avoid the clashes between module names.
we can import package as
from package_name import module_name

Package1
    __init__.py
    module1
    module2
    supackage
        __init__.py
        submodule1
        submodule2

request module -

Request module is a module in python which is used to do http request in python
it enables the communication with external server .


self - self is a keyword in python which refers the current instance of a class
it also help us to define and access the instance variable of a class.

static method are a special type of method which does not need self keyword while defining
the method and we can call this method without any instance of that class.
we use @staticmethod decorator to declare a static method in python.

super() keyword refers the parent class from a child class during inheritance
we can access the methods of parent class from child class with help of super() keyword.

Walrus operator is an operator in python which comes in 3.8 and onwards which assign the value
of a variable in expression only.
we use := operator as walrus operator.

difference between Set and FrozenSet:
In python both set and frozenset are used to store unique elements collections.
Set is mutable but frozenset is immutable.

Immutable - Immutable refers to an object whose state cannot modified after it is created.
Once immutable object is created it's value or contents can not be changed.

Example - Numbers, Strings, Tuple, Frozenset
Mutable -Mutable refers to an object whose state can be modified after it is created. means we can
add, remove element of a mutable objects.

Example - Lists, Dictionary, Sets, Bytearrays

Copy an objects

In python we copy an object in two ways:

Shallow copy -
In shallow copy we create a new object from an original object. The element of copied object will copy
the reference of the element of original object.
It means if we change the mutable elements inside copied object then original object will also
change.

deep copy -
In deep copy we also create a new object from an original object. The element of copied object
copied the element of original object recursively.
In deep copy the copied object is independent from the original object.

lambda method -
Lambda method is also known as anonymous method. We use lambda method for one time use of any function
for small work. There is no name for lambda function We use lambda keyword to define lambda function.

lambda arguments: expression

List comprehension - List comprehension we use to create a list from another list with applied
some expressions to each element of that list.

Dict comprehension - Dict comprehension we use to create a key value pair dictionary from another
list with applied some expressions to each element of that list.

Multithreading is way we can process multiple thread concurrently. For all the thread source and
destination may be same.

Because of GIL limitation multiprocess are more useful for cpu bound task.
GIL - Global interpreter lock.

Pickling & Un pickling - Pickling and unpickling both are used to serialize and de serialize the python
object into byte stream data and vice versa.

Pickling - In python we use pickle.dump to serialize the object into byte stream data
Unpickling - In python we use pickle.load to de serialize the byte stream data into object.

unittest -

In python unittest is a module which is used to write the test cases and execute it.
We use unittest.TestCases class which contains test methods inside that.

Test methods are the individual test case of a feature.

Assertion - Assertion is used to pass a test case. we have some builtin assertion in unittest
AssertTrue, AssertFalse, AssertEqual etc.

Test discovery -
unittest will discover all the test cases and run it which search pattern like 'test*.py'.

what is the difference between array and list in python?

    In python array is a data structure that store elements of same type in fixed size and take less
    memory than a list.

    The main difference between list and array are in array we can store similar type of element and
    in list we can store different types of elements.

    List has more property but it takes more memory than an array. Array has their fixed size it will
    not change, but list has dynamic size we can append elements, remove elements later also.

    To use array we need to import array first.

    from array import array

    my_array = array('i', [1, 2, 3, 4]) # Here i denotes the type of elements of array.

In python how many way we can declare tuple?

    1) Using parenthesis
        my_tuple = (1, 2, 3)

    2) using tuple constructor
        my_tuple = tuple([1, 2, 3])

    3) using a comma
        my_tuple = 1, 2, 3

    4) creating an empty tuple
        my_tuple = ()

    5) tuple with single element
        my_tuple = (34,)

    List

    my_list = [1, 2, 3]
    my_list = list([1, 2, 3])
    my_list = [x for x in range(3)]
    my_list = []
    my_list = [[1,2,3],['a', 'b', 'c']]
    single_list = [23]

1) What is the difference between NAN and None in python?

    NaN - It stands for Not a number. It is typically associated with numeric data
    type especially in the context of floating-point arithmetic.
    
    NaN is used in the context of numeric data, particularly when a mathematical
    operation results in an undefined or un presentable value.
    
    None - None is a special constant representing the absence of a value or a null
    value in python.

    None is a general placeholder representing the absence of a value, commonly used
    in various situations, such as the default return value for functions that do not 
    explicitly return a value.
    
2) which one is faster between list and tuple and why?
Ans -
In Python, tuples are generally faster than lists. This is because tuples are immutable, meaning
their elements cannot be changed after creation, which allows for various optimizations that improve
performance.
Lists, on the other hand lists are mutable and can be modified (elements can be added, removed, or changed),
which adds overhead for memory management and element manipulation.

Here's a more detailed comparison:

Memory Usage: Tuples use less memory than lists, making them more memory-efficient.
Iteration: Iterating over a tuple is faster than iterating over a list.
Immutability: Tuples are immutable, which allows for certain optimizations and safer use as keys in
dictionaries or elements in sets.
Operations: Lists are more versatile due to their mutability, allowing for a wider range of operations
like appending, inserting, and removing elements.

3) What is multiprocessing and how it different from multi threading?
Ans -
In Python involves using multiple process to execute code, allowing tasks to run in parallel on multiple
CPU cores. This approach is particularly benefical for cpu-bound tasks as it can significantly reduce exec-
tion time.


Difference between multiprocessing and multithreading

1) Concurrency model -
    Multiprocessing involves multiple process, each with its own memory space. This avoids the global
    interpretor lock(GIL) limitation allowing true parallelism.
    Multithreading involves multiple threads within the same process sharing the same memory space. due to
    GIL in cpython, threads can not execute bytecode simultaneously, limiting parallelism.

2) Memory sharing -
    Multiprocessing do not share memory. communication between process needs interprocess communication(IPC)
    mechanism like pipes or queue.
    Multithreading share the same memory space making communication between threads easier but increasing
    the risk of race conditions.

3) Performance -
    Multiprocessing is better for cpu-bound tasks because it can utilize multiple CPU cores.
    Multithreading more suited for I/O-bound tasks, whereas the primary constraint is waiting for
    external resources rather than CPU processing power.

4) Fault Isolation -
    Multiprocessing A crash in one process does not effect other process.
    Multithreading A crash in one thread can potentially bring down the entire process.

What is strip method in python?
Strip method in python used to remove leading and trailing whitespace from a string.
we can remove other things also from a string. whatever value we pass inside parenthesis of strip method
it will remove that.

we have lstrip and rstrip methods which remove leading and trailing whitespace from a text.

what is procedure in python?

In python procedure refers to a function that performs any specific task and does not return
any value explicitly or returns None value.
A procedure's main purpose is to execute statements, print output or make modifications without
necessarily producing a return value.

A procedure in python is essentially a function that
a) Has name.
b) Takes zero or more input parameters.
c) Execute a sequence of statements.
d) Does not return a value explicitly (or return None)

What is assert keyword in python?
The assert keyword in python used as a debugging aid that tests a condition as an internal
self check in a program. The assert keyword allows you to write assertions in your code. Assertions
are statements that you believe are always true at that point in your program.
If an assertions fails, python will raise an assertionError exception.

Example
x = 5
y = 10
assert x < y, "x should be less than y"

what is context in python?
context in python is refers an environment where python execute code. python handle this
scenario with help of "with" statement and context manager.
Basically context manager is an object which provide two dunder methods __enter__ and __exit__
for entering and exiting to the context.

when we deal with file system in those scenario when we open a file and if we forget to
close it then there is a chance to data leak so context will help here to close the file.

how to work with multiple database in django?

how to check password of a user in django?
if user is not None:
    password = 'input_password'
    if user.check_password(password):
        print("Password is correct.")
    else:
        print("Password is incorrect.")

in django how we can return a pdf to browser


x = 5
y = 5
how we can say that both are same object in python

In Python, you can check if two variables point to the same object using the is operator. The is operator checks whether two variables refer to the same object in memory.
x is y checks if both x and y refer to the same object in memory.

Map method -
Definition -

The map() function in python applies a given function to all items in an iterable(like list or tuple)
and returns a map object(which is an iterator). It processes each item of iterable using the function provided.

Syntax -
map(function, iterable)

function - A function that applies to each element of iterable.
iterable - An iterable like list or tuple.

Filter method -
Definition -

The filter() method in python constructs an iterator from elements of an iterable for which a function
returns True. In other words, It filters out the elements that do not meet the condition provided by function.

syntax -
filter(function, iterable)

function - A function that test each element of the iterable; returns True to keep the element or False to
    discard it.

iterable - An iterable like a list, tuple etc.

The key difference between filter and map are:
map() method applies a function to all elements in an iterable and transform them while filter() method
selects some elements based on a condition.

map() requires a function that returns a new value for each element whereas filter() requires a function
that returns a boolean(True/False) to determine whether to keep or discard each element.

What is the difference between index method and find method of string in python?
both index method and find method are used to search a substring inside a string in python the basic difference
between both are find method returns -1 if it does not find the match but index method return ValueError
when it does not find the match.

What is the difference between positional argument and keyword argument?


positional argument -
definition - Positional argument are passed to a function in a specific order, based on their position.
order matters - the function expects argument in a certain order, and they are assigned to the corresponding
parameters based on their position.

Keyword argument -
definition - Keyword argument are passed to a function with parameter name specified explicitly.
Order doesn't matter - Since you are using parameter name, the order in which you pass them doesn't matter.

what is the difference between jwt and oauth2 authentication?

JWT(Json Web Token) and OAuth2(Open Authorization 2.0) are both popular protocols used for securing
APIs, but they serve different purposes and are used in distinct ways.

JWT(Json Web Token) -
JWT is a token based authentication mechanism that uses tokens to verify a user's identity.
The token contains a payload(usually user information and permission), is signed with a secret,
and can be verified without needing to access the original data source again. JWT are stateless,
,meaning no session data is stored on the server.

Structure -
JWTs consist of three parts: Header, Payload, and signature.
header.payload.signature

Token Creation - Encodes user data and an expiration time, then sign it with secret key.
Token Verification - Decodes the JWT and verifies the signature; if valid, processes the user's
request.

Oauth2 -
Oauth2 is an authorization protocol that grants limited access to a  user's resources on a third
party service without sharing the credentials. Oauth2 involves multiple roles: client(the app
requesting access), resource owner(the user), authorization server(the service providing tokens)
and resource server(API server with protected resources).

Use Case -
Oauth2 is widely used when third-party applications need access to user data on behalf of the user,
such as logging in with google or accessing a github account.

key differences -

Jwt -
Purpose - Primarily used for authentication.
Token Type - Self contained token with user info.
Usage Context - Stateless, suited for single app sessions.
Complexity - Simple.
Example Use Case - Authenticating API Users in a single app.

Oauth2 -
Purpose - Primarily used for authorization.
Token Type - Access token, often with refresh tokens.
Usage Context - Used for third party, multi-app scenarios.
Complexity - More complex, with multiple grant types.
Example Use Case - Logging in with Google/Facebook.


how to declare async task in python?
Asynchronous task in python allow you to run code that doesn't block other parts of our program,
which can be especially useful for I/O bound tasks like network requests, file I/O or database
operations. with the asyncio library, python provides built in support for asynchronous programing.

Key concepts in Asynchronous programming
1) Coroutines -
    Functions defined with async def, which allow you to write asynchronous code.
2) Awaiting -
    The await keyword pauses the coroutine until the awaited task completes, allowing
    other task to run meantime.
3) Event Loop -
    The core of asyncio, which runs asynchronous tasks and coroutines.
4) Tasks -
    Used to schedule coroutines concurrently on the event loop.
    

how to write unittest in using external url request?

When writing unittest for methods that requests to external urls, you typically don't
want actually make the network requests instead, you can use mocking to simulate the behaviour of
the external services. This way you can test how your code handle the response without relying
on the external service itself.

Python's unittest.mock library provides the patch function, which lets you replace parts of your
system under test and control their behaviour during the test.


what are the types of authentications used in python?
In python, we have several types of authentication methods are used to secure applications, access
API, and interact with database or other external systems.

1. Basic Authentication -
    Basic authentication sends the username and password in an HTTP header encoded as Base64
    string.

    import requests

    url = 'https://api.example.com/protected'
    response = requests.get(url, auth=("username", "password"))

    print(response.status_code)
    print(response.json())

2. Token Based Authentication (Bearer token) -
    In token-based authentication, a client authenticates once(using username and password)
    and receives a token in return. This token is then used for all subsequent requests.
    JWT(JSON WEB TOKEN) is a popular choice for token-based authentication.

    import requests

    url = 'https://api.example.com/protected'
    headers = {'Authorization', "Bearer your_access_token"}
    response = requests.get(url, headers=headers)

    print(response.status_code)
    print(response.json())

3. Oauth2 Authentication -
Oauth2 is commonly used when application want to access the user data from third-party services.
Oauth2 requires client Id, client secret and redirect URI, and can involve complex flows such
as Authorization code Flow and Implicit flow.

4. Multi Factor Authentication -
MFA requires more than one form of verification(like a password and a one-time code) to enhance
security. Typically, one time code are sent via SMS, email or an authenticator app. Implementing
MFA often involves integrating with services of libraries that support it.


how to handle any forgeries happened in your scripts?

Handling forgeries in python scripts involves identifying and mitigating unauthorized modifications
or malicious activities.

Key techniques for handling forgeries -

a) Input Validation -
    Validate all inputs to prevent malicious data injection.

b) Use Cryptographic signature -
    Secure sensitive data and ensure its integrity using cryptographic hashes or digital signature
    ex - JWT

c) Logging and monitoring -
    Record event and monitor logs for unusual activity to detect forgeries early.

d) Secure and secrets and credentials -
    Avoid hard coding sensitive information (ex - API Keys) in the scripts. Use environment
    variables or secure storage.

e) Error Handling -
    Gracefully handle errors and avoid exposing sensitive information.

f) Access control -
    Limit access to scripts or resources based on roles and permissions.

how we improve the performance of our code?

a) Optimize algorithm
b) Use builtin function and libraries
c) Leverage list comprehensions
d) Avoid unnecessary loops
e) Multi threading and multi processing
f) caching with function.lru_cache
g) Avoid global variables

which one is more good in terms of performances raw sql query or orm?

The choice between using raw SQL queries or Django ORM depends on the specific use case,
performance requirements, and developer experience.

Django ORM -
The django Object-relational mapping (ORM) provides an abstraction layer that allows you to
interact with database using python objects instead of writing raw SQL.

Advantages of Django ORM -
a) Ease of use -
    Queries are written in python, making them easy to read and write.
    Abstracts complex sql syntax and database specific details.

b) Security -
    Prevents SQL injection attacks by automatically escaping inputs.

c) Maintainability -
    Easier to maintain as the queries integrate seamlessly with django models.

d) Database Agnosticism -
    Makes it easier to switch between databases without changing the queries.

Performance -
    For simple to moderate complex queries Django ORM PERFORMS WELL.
    It might not be optimal for very complex queries, (eg - multiple joins, aggregations)
    due to the abstraction overhead.

Advantage of raw SQL -
a) Fine-Grained Control -
    Provides complete control over the query's execution and optimization.
    Useful for complex queries where ORM abstractions may introduce inefficiencies.

b) Better performance -
    Raw SQL an be more efficient as you can optimize queries specially for the database
    and avoid ORM overhead.

c) Access to advanced features -
    Allows the use of database-specific features like CTEs (Common table expressions), windows
    functions, or custom optimizations.

how is garbage collector works in python?

The garbage collector in python is responsible for automatically managing memory by reclaiming
unused or unreachable objects, preventing memory leaks. python's garbage collection is part of
memory management system and works in conjunction with reference counting and a cyclic garbage
collector.

a) Reference counting -
    Python keeps track of how many references point to an object.
    An object is deallocated when its reference count drops to zero.

b) Cyclic garbage collector -
    Reference counting fails with cyclic references (eg., objects referencing to each other)
    python cyclic garbage collector detects and removes such cycles.

What is sorting and what are the types of sorting we have?

Sorting is a process of arranging elements in a collection(such as a list or an array) in a
particular order, either in ascending or descending order. Sorting is widely used in various
applications to organize data for easier searching, analysis, or presentation.

Types of sorting algorithm -
1) Built-in sorting function in python -
    sorted() - returns a new sorted list without modifying the original.
    list.sort() - Modifies the list in place and does not return any new list.
    Both use timsort, which is a hybrid sorting algorithm derived from merge sort and insertion
    sort.

Common sorting algorithm -
1) Bubble Sort - Repeatedly swaps adjacent elements if they are in the wrong order.
    Easy to understand, but inefficient for large datasets.

2) Selection Sort - Selects the smallest elements from unsorted part and places it at the correct
    position. Simple but slower compared to others.

3) Insertion Sort - Builds the sorted list one item at a time by inserting elements at the correct
    position. Efficient for small or nearly sorted datasets.

4) Merge Sort - Divides the list into halves, sort each half and merge them.
    stable and efficient for large datasets, but require extra memory.

5) Quick Sort - picks a pivot and partitions the array into elements less than and greater than
    the pivot, then short them recursively. Highly efficient, but performance depends on pivot
    selection.

6) Timsort (Used by python sorted() and list.sort())
    Hybrid sorting algorithm combining merge sort and insertion sort
    Optimized for real-world data and efficient on nearly sorted data.

how to configure ec2 instance in aws by python



what is difference between iterators and generators?

The basic difference between iterators and generators are
we use iterators when we need full control over how values are generated and iterated.
we use generators for simpler, more efficient approach when working with large or infinite
sequences.

Iterators -
An iterator is an object that implements two methods -
__iter__() - Returns the iterator objects itself.
__next__() - Return the next value from the sequence. Raise a StopIteration exception when no
more item are available.
It is reusable.
More complex.
Manage state explicitly (using instance variable.)

Generators -
A generator is a simpler way to create iterators using function instead of a class.
A generator function uses the yield keyword to produce values one at a time.

It automatically saves the state of the function between yield calls.
No need to implement __iter__() and __next__() explicitly.

Generators are lazy , meaning they produce items one at a time do not store the entire sequence
in the memory.
Suitable for large numbers of sequence.
Can not be reused after iteration.

What is the difference between a function and a method in the programing language?

Function -
A function is a block of reusable code that is not tied to any object.
It can be defined using def keyword and called directly.
Functions are part of the global scope or a module and can be used independently.

Methods -
A method is a similar of function but is associated with an object(or class).
It is called on an object and can access the data(attributes) of that object.
Methods are defined inside a class.

What is SDLC?
SDLC stands for software development life cycle. It is a structured process used by software developers and
project teams to design, develop, test, deploy and maintain software applications.

Goal of SDLC - Deliver high quality software that meets customer expectations, is completed within time
and within cost estimates.

Phases of SDLC -
1) Requirement gathering and analysis.
2) System design
3) Implementation
4) Testing
5) Deployment
6) Maintenance

Why is SDLC important?
1) Ensure clear planning and execution.
2) Helps with cost and time management.
3) Provides a predictable, repeatable process.
4) Improve software quality.
5) Makes project traceable and measurable.

What is water fall model?
Wter fall SDLC is a traditional, linear software development model, where project flows sequential

What is SOLID principle?
The solid principles are five design principles intended to make software designs more understandable,
flexible, and maintainable. They are widely used in object-oriented programming, including in python, to write
clean and scalable code.

S - Single responsibility principle
O - Open/closed principle
L - Liskov substitution principle
I - Interface segregation principle
D - Dependency inversion principle

1) Single responsibility principle (SRP)
    A class should have only one reason to change, i.e It should do one thing and do it well.

    Use case - If a class handles both data processing and logging, a change in logging logic would force
    a change in the class even though its core purpose is data processing.

2) Open/Close principle (OCP)
    A class should be open for extension but closed for modification.

    Use case - When adding new functionality, we should extend existing code not modify it.

3) Liskov Substitution Principle(LSP)
    Object of a superclass should be replaceable with objects of its subclass without affecting the
    correctness of the program.

    Use case - Ensure subclass don't break behaviour expected by their parent class.

4) Interface segregation Principle (ISP)
    A class should not be forced to implement methods. it's does not use.
    python doesn't have interfaces like java, but we use abstract base class to mimic this.

    Use case - Keep interface or base classes focused and small.

    In simple words don't give a class more methods than it needs.
    Instead of one fat interface, create multiple small, focused interfaces so that classes only
    implement what they actually use.

5) Dependency Inversion Principle (DIP)
    High level modules should not depend on low-level modules, but both should depend on abstractions.

    Use case - Instead of hard coding dependencies, pass them as interfaces/abstractions - helps in testing
    and decoupling.

    In simple words Your business logic(high-level module) should not depend directly on low level
    concrete class(like database, file storage, etc)

    instead, they should depend on interfaces or abstract classes - and actual implementations should be
    plugged in when needed.


Why do we follow SOLID principles?
We follow SOLID principles in programming language especially in object-oriented software development to
1) Improve Code maintainability.
    problem - Code become hard to change as it grows.
    SOLID benefit - each class or module has a specific purpose, making the code easier to update, debug,
    or refactor.

2) Enable scalability and extensibility.
    problem - Adding new features often breaks existing functionality.
    SOLID benefit - You can extend code without modifying the existing, stable codebase.

3) Promote re usability.
    problem - Developers keep duplicating the logic across modules.
    SOLID benefit - Well separated responsibilities and abstract layers allow code reuse.

4) Simplify testing.
    Problem - Tight coupling make unit testing difficult.
    SOLID benefit - Loose coupling and abstraction allow independent testing of components.

5) Improve team collaboration.
    Problem - Teams get blocked waiting on each other due to tight coupled code.
    SOLID benefit - Clear boundaries and contracts(interface/abstractions) allow teams to work in parallel.

6) Reduce bugs.
    Problem - Change in one area cause unexpected bugs elsewhere
    SOLID benefit - Encapsulation and well-defined responsibilities reduce side effects.

What is ACID properties in database?
ACID is a set of four key properties that ensure reliable transactions in a database system.
Each letter in ACID stands for

A- atomicity
All operations in a transaction either complete fully or not at all.

C- consistency
The database remains in a valid state before and after the transaction.

I- isolation
Concurrent transactions do not interfare with each other.

D- durability
Once transaction is committed, the data is permanently saved, even if the system crashes.

Real Life example

1. Debit ₹1000 from Account A
2. Credit ₹1000 to Account B
3. Commit transaction

Atomicity - Either both debit and credit happens or not at all.
If system crashes after debit bit before credit the entire transaction is rolled back

Consistency - The total amount in both the accounts remains unchanged after the transfer.
Example:
Before: A = ₹5000, B = ₹2000 → Total = ₹7000
After: A = ₹4000, B = ₹3000 → Total still = ₹7000

Isolation - Transaction running at the same time do not affect each other.
If two users try to transfer money at same time:
User a is transferring 1000
User b is transferring 2000

They run independently don't see each other's in progress updates.

Durability - Once transfer is committed, it is permanent.
Even if there is power failure or crash afterward - the 1000 rupees is not lost. It's safely stored in the
database.

In django we are using @transaction.atomic decorator for atomicity

reduce - In python reduce is a function from the functools modules. It's used to apply a rolling
computation to items in an iterable (like a list), reducing it to a single cumulative value.
Basically it combined all elements into one value (aggregation).


