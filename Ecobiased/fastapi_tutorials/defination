FastApi provides swagger UI for documentation which consists of all the endpoint and you can try it
out also. It also provides Redoc documentation also automatic documentation.

FastApi based on latest python with type support also based on pydantic model.

It based on open standards

1) Json schema
2) Open Api

Security and authentication

HTTP Basic
OAuth2(Also with JWT tokens)
API Keys in
Headers
Query parameters
Cookies, etc

Dependency Injection unlimited "Plugins"
Tested - It used pytest for testing API.

Starlette features - It is an another framework available on python programing language.
FastApi has below features of starlette.

WebSocket Support
GraphQL Support
In-progress background tasks
Startup and Shutdown events.

Test client built on requests.
CORS, GZIp, Static Files, Streaming responses.
Session and cookie support.

Other Support -
SQL databases
NoSQL databases
GraphQL

Command to install fastapi
pip install FastAPI
pip install uvicorn - to run server we need uvicorn

command to run the server -
uvicorn main:app --reload

here uvicorn is the library name main is the module name is file main.py and app is the instance name
app = FastAPI()

In other framework we call it endpoint, url but in fastapi we call it path.

@app.get('/')
def index():
    return {'data': {'name': 'Ashish'}}

Here
below function is known as path operation function
def index():
    return {'data': {'name': 'Ashish'}}

.get is called operation

@app is called path operation decorator.

('/') - This is called path.

FastAPI reads the code line by line.

below is the url to goes to swagger url
http://localhost:800/docs

below is the url to goes to redoc url
http://localhost:800/redoc

Response model - What is this and when we use it.
When we wanted to see the response of a particular row in documentation also all the columns are visible.
if we do not wanted to show some particular column suppose id in the response then we can hide them with help of
response model. for that we write pydentic model ie pydentic schema with those columns which we wanted to display.

To hash a password in fastAPI we use passlib library
pip install passlib

then from passlib.context import CryptContext

In fastAPI we have tag which used to define the routes in a proper way.

In the router we are doing everything means going to path fetching data from database and returning response
But the ideal use of routes is to go to the path and return something. So we can move all the logics inside
repository directory files.

Need to install a library python-jose for jwt token.

How we handle validation in FastAPI?

In FastAPI, validation is automatic and powerful, thanks to pydentic models.
We define data schemas using pydentic BaseModel, and FastAPI automatically validates input data (from JSON, query
parameters, form etc) against those schemas.

1) Basic Validation Example (Request Body)

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field, EmailStr

app = FastAPI()

# Define request body model
class User(BaseModel):
    name: str = Field(..., min_length=3, max_length=50)
    age: int = Field(..., gt=0, lt=120, description="Age must be between 1 and 119")
    email: EmailStr
    is_active: bool = True

@app.post("/users/")
def create_user(user: User):
    if not user.is_active:
        raise HTTPException(status_code=400, detail="User must be active")

    return {"message": "User created successfully", "user": user}

FastAPI automatically validates
    name - must be between 3 to 50
    age - must be between 0 to 120
    email - must be a valid email address
    if validation fails - FastAPI automatically returns a 422 Unprocessable entity error with detailed message.


2) Validation with Query Parameters

from fastapi import Query

@app.get("/items/")
def read_items(skip: int = Query(0, ge=0), limit: int = Query(10, le=100)):
    return {"skip": skip, "limit": limit}

skip must be â‰¥ 0

limit must be â‰¤ 100
If invalid, FastAPI automatically returns a validation error.

3) Validation with Path Parameters

from fastapi import Path

@app.get("/items/{item_id}")
def get_item(item_id: int = Path(..., gt=0)):
    return {"item_id": item_id}

If item_id â‰¤ 0 â†’ validation fails automatically.

4) Custom Validation using Pydantic Validator

You can add custom validation logic:

from pydantic import validator

class Product(BaseModel):
    name: str
    price: float
    discount: float

    @validator("discount")
    def check_discount(cls, v, values):
        if "price" in values and v > values["price"]:
            raise ValueError("Discount cannot exceed price")
        return v

Combine with HTTPException for Business Logic Validation

@app.post("/products/")
def create_product(product: Product):
    if product.price <= 0:
        raise HTTPException(status_code=400, detail="Price must be positive")
    return product


What do you mean by pydentic model in fastapi?

Pydentic model in fastapi is a data validation and serialization model that defines the structure of request and
response data using python type hints.
It comes from pydentic library, which ensures that data received from the client(like, JSON, query, params,
forms, etc) is validated, converted to correct types, and handled safely before reaching your business logic.


Key features of pydentic models -
Automatic data validation(type checking and value constraints)
Automatic data conversion(eg. string "25" become integer 25)
Error reporting - (returns structured validation errors automatically)
Serialization/Deserialization - (Convert between python objects and JSON)
Used for request & response models in FASTAPI

What is the difference between restapi and fastapi?
defination -
RestAPI is a design style or architecture for building APIs over HTTP(not a framework or library)
FastAPI is a python web framework used to build RESTAPIs quickly and efficiently.

Type -
RESTAPI is a concept/standard
FASTAPI is an implementation(framework)

Purpose -
RESTAPI defines how clients and servers communicate using HTTP methods(GET, POST, PUT, DELETE, etc)
FastAPI provides tools and libraries to easily build RESTful APIS that follow REST principles.

Protocol -
RestAPI - based on HTTP/HTTPS and follow stateless communication.
FASTAPI - Uses starlette for async and pydentic for validation to build restful APIs over HTTP.

Language/platform -
RESTAPI can be implemented in any language(python, java, Nodejs, etc)
FASTAPI  - Python only framework that helps you implement REST APIs.

Why FASTAPI is popular?
FASTAPI stands out because
Super fast performance - built on starlette + async support
automatic documentation - via swagger doc UI and redoc ui
builtin validation - using pydentic models
easy authentication/authorization handling
Type hinting support - great with modern python typing
Asynchronous support - handles thousands of requests efficiently.

what are the json dependencies in fastAPI?

When we say json dependencies in FastAPI, we are talking about the libraries, and mechanisms FastAPI uses to
handle JSON data - ie parsing(reading), validation and serialization (returning JSON Response)

FastAPI is built on top of starlette and pydentic, so it relies on their JSON-handling capabilities.

Core JSON dependencies in FastAPI -
Pydentic - data validation and serialization - validates request JSON body and converts python objects to JSON.

JSON(python standard library) - basic JSON encode/decode - converts between python dict and json string internally

orjson(optional, faster) - High performance JSON parser - used when you install FastAPI with [all] extras

ujson(option, alternative) - ultra-fast json library - another option for faster json handling

starlette.responses.JSONResponse - Returns HTTP responses in JSON format - Used automatically when you return dict
or return JSONResponse()

What are the difference between path parameter and query parameter?
Path parameter are part of the URL path itself, they are required and typically used to identify a specific
resource.

from fastapi import FastAPI

app = FastAPI()

@app.get("/items/{item_id}")
def get_item(item_id: int):
    return {"item_id": item_id}

GET /items/10
The {item_id} part is a path parameter.
it's required -/items/ without id it gives 404 error.
Typically use - Get, update, or delete a single resource by id

Query parameter -
Query parameter are passed after ? in the URL
They are optional and usually used for filtering, sorting, pagination or search.

from fastapi import FastAPI

app = FastAPI()

@app.get("/items/")
def list_items(skip: int = 0, limit: int = 10):
    return {"skip": skip, "limit": limit}

GET /items/?skip=20&limit=5

both skip and limit are query parameters. they are optional because default values are provided.
you can pass one, both or none.

You can combine path + query in the same endpoint.

i am using above code and provided port as 9000 but when i run my app with below command uvicorn main:app --reload
it started on 8000 port only

i am using above code and provided port as 9000 but when i run my app with below
command uvicorn main:app --reload it started on 8000 port only

That block only executes when you directly run your script like this:
python main.py

In that case, it will indeed start the server on port 9000.
uvicorn main:app --reload

But when you use this command:

uvicorn main:app --reload


ðŸ‘‰ You are not running your script directly â€” instead, the uvicorn CLI imports your app (main:app) and starts the server itself.

That means the line inside

if __name__ == '__main__': ...


is never executed, so your port settings there are ignored.
By default, Uvicorn starts on port 8000 unless you specify another one in the CLI command.

